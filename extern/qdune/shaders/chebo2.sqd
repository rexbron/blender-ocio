# version using step() without using any logic (filterstep() TODO)
# surface chebo2(color white_color = 1, black_color = 0;)
# {
# 	point PP = transform("shader", P);
# 	float x = mod(xcomp(PP), 1);
# 	float y = mod(ycomp(PP), 1);
# 	float z = mod(zcomp(PP), 1);
# 	if (x < 0) x += 1;
# 	if (y < 0) y += 1;
# 	if (z < 0) z += 1;
# 	float fx1 = filterstep(x, 0.5);
# 	float fx2 = 1 - fx1;
# 	float fy1 = filterstep(y, 0.5);
# 	float fy2 = 1 - fy1;
# 	float fz1 = filterstep(z, 0.5);
# 	float fz2 = 1 - fz1;
# 	float d = (fx1*fy1 + fx2*fy2)*fz1 + (fx1*fy2 + fx2*fy1)*fz2;
# 	Ci = Cs * diffuse(faceforward(normalize(N), I)) * mix(black_color, white_color, d);
# 	Ci *= Cs * diffuse(faceforward(normalize(N), I));
# 	Oi = Os;
# 	Ci *= Oi;
# }
surface chebo2
param color white_color 1 1 1
param color black_color 0 0 0
temp point PP
temp float x
temp float y
temp float z
temp float fx1
temp float fx2
temp float fy1
temp float fy2
temp float fz1
temp float fz2
temp float d
const float $1 1
const float $2 0
const float $3 0.5
temp normal $4
temp color $5
temp float $6
temp bool $7
global P Ci Cs Oi Os N I
codesegment
	ptransform1	PP "shader" P
	xcomp				x PP
	mod					x x $1
	ycomp				y PP
	mod					y y $1
	zcomp				z PP
	mod					z z $1
	ifltff			$7 x $2
	cond_push		$7
	addfff			x x $1
	cond_reset
	ifltff			$7 y	$2
	cond_push		$7
	addfff			y y $1
	cond_reset
	ifltff			$7 z $2
	cond_push		$7
	addfff			z z $1
	cond_reset
	step				fx1 x $3
	subfff			fx2	$1 fx1
	step				fy1 y $3
	subfff			fy2	$1 fy1
	step				fz1 z $3
	subfff			fz2	$1 fz1
	mulfff			$6 fx1 fy1
	maddfff			$6 fx2 fy2
	mulfff			d $6 fz1
	mulfff			$6 fx1 fy2
	maddfff			$6 fx2 fy1
	maddfff			d $6 fz2
	mixv				Ci black_color white_color d
	normalize			$4 N
	faceforward1	$4 $4 I
	diffuse				$5 $4
	mulvvv				$5 $5 Cs
	mulvvv				Ci Ci $5
	movvv					Oi Os
	mulvvv				Ci Ci Oi
	return
